/*
	MAGU Scanner/Parser
	Adrián Martínez A01280252
	Estefanía Guajardo A00813202
*/

// Para permitir el uso de variables y que los métodos no sean estáticos por default
options {
	STATIC = false ;
}

PARSER_BEGIN(magu)
class magu
{
	public static void main(String[] args) throws ParseException
	{
		try
		{
			magu scanner = new magu(System.in);
			scanner.Programa();
			System.out.println("OK!");
		}
		catch(ParseException e)
		{
			System.out.println(e.getMessage());
			System.out.println("Error!");
		}
	}

	// Variable donde se guarda el valor de las expresiones
	int valorExp = 0;
}
PARSER_END(magu)

TOKEN:
{
		< TK_FORWARD : "forward" | "f" >		{}
	|	< TK_LEFT : "left" | "l" >				{}
	|	< TK_RIGHT : "right" | "r">				{}
	|	< TK_PENCILUP : "pencilup" | "pu" >		{}
	|	< TK_PENCILDOWN : "pencildown" | "pd" >	{}
	|	< TK_MOVE : "move" | "m" >				{}
	|	< TK_SHOWPOS : "showpos" | "sp" >		{}
	|	< TK_HIDEPOS : "hidepos" | "hp" >		{}
	|	< TK_HOME : "home" | "h" >				{}
	|	< TK_CURVE : "curve" | "cv" >			{}
	|	< TK_CLEAR : "clear" | "c" >			{}
	|	< TK_WHILE : "while" >					{}
	|	< TK_IF : "if" >						{}
	|	< TK_ELSE : "else" >					{}
	|	< TK_ARR : "arr" >						{}
	|	< TK_FUNC : "func" >					{}
	|	< TK_EQ: "=" >							{}
	|	< TK_NE: "<>" >							{}
	|	< TK_LT: "<" >							{}
	|	< TK_GT: ">" >							{}
	|	< TK_LPAR: "(" >						{}
	|	< TK_RPAR: ")" >						{}
	|	< TK_LBRACKET: "[" >					{}
	|	< TK_RBRACKET: "]" >					{}
	|	< TK_COMMA: "," >						{}
	|	< TK_PLUS: "+" >						{}
	|	< TK_MINUS: "-" >						{}
	|	< TK_MULT: "*" >						{}
	|	< TK_DIV: "/" >							{}
	|	< TK_ID :  ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9"])* > {}
	|	< TK_CTE_I : (["0"-"9"])+ >				{}

}

SKIP:
{
	" "	| "\r\n" | "\t"
}

void Programa() : {}
{   
    ( 
    	  LOOKAHEAD(2) Funcion()
    	| LOOKAHEAD(2) Asignacion()
    	| Definicion_Func()
    	| Condicion()
    	| While()
    	| Arreglo()
    	| valorExp = Bool() {System.out.println(valorExp);} )+
    <EOF>
}

void Func() : {}
{
    ( <TK_FORWARD> | <TK_LEFT> | <TK_RIGHT> | <TK_PENCILUP> | <TK_PENCILDOWN> | <TK_MOVE> | 
    	<TK_SHOWPOS> | <TK_HIDEPOS> | <TK_HOME> | <TK_CURVE> | <TK_CLEAR> )   
} 

void Funcion() : {}
{
    ( Func() | <TK_ID> ) <TK_LPAR> ( ( Exp() ) ( <TK_COMMA> Exp() )* )? <TK_RPAR>
}

int Exp() : {int resultado; int term;}
{
	resultado = Termino()
	( 
		 <TK_PLUS>
		 term = Termino()
		 {resultado += term;}
		
		| 

		<TK_MINUS>
		term = Termino()
		{resultado -= term;}

		)*
	{return resultado;}
}

int Termino() : {int resultado; int fact;}
{
	resultado = Factor()
	( 
		 <TK_MULT>
		 fact = Factor()
		 {resultado *= fact;}
		
		| 

		<TK_DIV>
		fact = Factor()
		{resultado /= fact;}

		)*
	{return resultado;}
}

int Factor() : {Token t;}
{
	// Si el token es variable, sacar su valor de la tabla
	t = <TK_ID>
	{return TablaVariables.getValor(t);}

	|

	<TK_LBRACKET> Exp() <TK_RBRACKET>

	|

	// Si es constante, hacer parse a entero
	t = <TK_CTE_I>
	{return Integer.parseInt( t.image );}
}


void Asignacion() : { Token var; int valor;}
{
	var = <TK_ID>
	<TK_EQ> 
	valor = Exp()

	{
		TablaVariables.asignarValor(var,valor);
	}

	// <TK_ID> ( <TK_LBRACKET> Exp() <TK_RBRACKET> )? <TK_EQ> Exp()
}


int Bool() : {int resultado; int exp;}
{
	resultado = Exp()
	( 
		<TK_LT>
		exp = Exp()
		{ if(resultado >= exp) {resultado =  0;} } // Si resultado no es menor que el exp, es falso, 0
		|
		<TK_GT>
		exp = Exp()
		{ if(resultado <= exp) {resultado =  0;} } // Si resultado no es mayor que el exp, es falso, 0
		|
		<TK_NE>
		exp = Exp()
		{ if(resultado == exp) {resultado =  0;} } // Si resultado es igual que el exp, es falso, 0

	)?

	{return resultado;}
}

void Secuencia() : {}
{
	<TK_LPAR> ( LOOKAHEAD(2) Funcion() | While() | Asignacion() | Condicion() ) ( <TK_COMMA> ( LOOKAHEAD(2) Funcion() | While() | Asignacion() | Condicion() ) )* <TK_RPAR> 
}

void While() : {}
{
	<TK_WHILE> <TK_LPAR> Bool() <TK_RPAR> Secuencia()
}

void Definicion_Func() : {}
{
	<TK_FUNC> <TK_ID> <TK_LPAR> ( <TK_ID> ( <TK_COMMA> <TK_ID> )* )? <TK_RPAR> Secuencia()
}

void Condicion() : {}
{
	<TK_IF> <TK_LPAR> Bool() <TK_RPAR> Secuencia() (<TK_ELSE> Secuencia() )?
}

void Arreglo() : {}
{
	<TK_ARR> <TK_ID> <TK_LBRACKET> Exp() <TK_RBRACKET> (<TK_EQ> <TK_LPAR> Exp() (<TK_COMMA> Exp() )* <TK_RPAR> )?
}